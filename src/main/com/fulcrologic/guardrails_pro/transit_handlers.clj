(ns com.fulcrologic.guardrails-pro.transit-handlers
  (:require
    [com.fulcrologicpro.cognitect.transit :as transit])
  (:import
    com.fulcrologicpro.com.cognitect.transit.DefaultReadHandler
    java.util.regex.Pattern
    (java.io ByteArrayOutputStream ByteArrayInputStream)))

(deftype UnknownTaggedValue [tag value])

(defonce transit-handlers
  (atom
    {:writers {}
     :readers {}}))

(defn type-handler
  [type tag type->ground ground->type]
  {:writer {type (transit/write-handler
                   (fn [_] tag)
                   (fn [t] (type->ground t))
                   (fn [r] (str tag "#" r)))}
   :reader {tag (transit/read-handler ground->type)}})

(defn install-type-handler!
  "Install a type handler (generated by `type-handler`) into the global Fulcro transit support registry. This registry
   can be used by any Fulcro-aware facility that needs to use transit for any standard purpose where app-specific type
   support is desired."
  [t]
  (swap! transit-handlers (fn [m]
                            (-> m
                              (update :readers merge (:reader t))
                              (update :writers merge (:writer t)))))
  nil)

(defn read-handlers
  "Returns a map that can be used for the :handlers key of a transit reader, taken from the current type handler registry."
  []
  (get @transit-handlers :readers {}))

(defn write-handlers
  "Returns a map that can be used for the :handlers key of a transit writer, taken from the current type handler registry."
  []
  (get @transit-handlers :writers {}))


(defn writer
  "Create a transit writer.

  - `out`: An acceptable output for transit writers.
  - `opts`: (optional) options to pass to `com.fulcrologicpro.cognitect.transit/writer` (such as data type handlers)."
  ([out] (writer out {}))
  ([out opts] (transit/writer out :json (update opts :handlers merge (write-handlers)))))

(defn reader
  "Create a transit reader.

  - `opts`: (optional) options to pass to `com.fulcrologicpro.cognitect.transit/reader` (such as data type handlers)."
  ([in] (reader in {}))
  ([in opts] (transit/reader in :json (-> opts (update :handlers merge (read-handlers))))))


(defn transit-clj->str
  ([data] (transit-clj->str data {}))
  ([data opts]
   (let [opts (cond-> (dissoc opts :metadata?)
                (not (false? (:metadata? opts))) (assoc :transform transit/write-meta))]
     (with-open [out (ByteArrayOutputStream.)]
       (transit/write (writer out opts) data)
       (.toString out "UTF-8")))))

(defn transit-str->clj
  "Use transit to decode a string into a clj data structure. Useful for decoding initial app state
   when starting from a server-side rendering."
  ([str] (transit-str->clj str {}))
  ([str opts]
   (transit/read (reader (ByteArrayInputStream. (.getBytes str "UTF-8")) opts))))

(defonce _
  (do
    (install-type-handler!
      (type-handler
        Pattern "guardrails/regex"
        str re-pattern))
    ;; NOTE: for user unknown tagged values
    ;;  - but should not fail in grp code
    (install-type-handler!
      (type-handler
        UnknownTaggedValue "guardrails/unknown-tag"
        #(vector (.tag %) (.value %))
        (fn [[tag value]]
          (read-string
            (str "#" tag " " value)))))))

;; NOTE: for user specific tags with no transit handlers
(def default-write-handler
  (let [tag "guardrails/default-handler"]
    (transit/write-handler
      (fn [_] tag)
      (fn [x] (pr-str x)))))

(def default-read-handler
  (reify DefaultReadHandler
    (fromRep [this tag rep]
      (read-string rep))))

(def read-edn #(transit-str->clj % {:default-handler default-read-handler}))
(def write-edn transit-clj->str)
