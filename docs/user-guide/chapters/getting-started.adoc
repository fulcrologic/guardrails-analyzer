== Getting Started

When you signed up for Copilot you should have received an email with a license, maven credentials, and some basic
setup instructions. You'll need to follow those directions first. The steps are:

* Make sure you have https://clojure.org/guides/getting_started[Clojure Tools Deps] installed, and updated to the latest version.
* Install your license file into your home directory under `$HOME/.copilot/copilot.license`
* Add your maven credentials to `$HOME/.m2/settings.xml`
* Add the copilot daemon as an alias in your project or global deps.

=== Java JVM

Copilot is tested against JDK 1.8 and 1.11. It should work with Oracle's official JDK and OpenJDK.

=== Supported Operating Systems

Copilot is written in Clojure and runs on the JVM. It should work on any operating
system that is well-supported by the https://clojure.org/guides/getting_started[Clojure tools deps] system.

If you are using Windows then we recommend using Windows Subsystem for Linux.

=== Your License

Copilot requires a valid license to run. You must place your license file in
`$HOME/.copilot/copilot.license`. You can find your $HOME directory using a REPL:

[source, clojure]
-----
(System/getProperty "user.dir")
=> "/Users/bob"
-----

NOTE: We will use the common *NIX shorthand `~` to mean `$HOME` in the remainder of this document.

=== Maven Credentials

The commercial code for Copilot is on a private maven repository. You should have received credentials and instructions
in your license email. Basically you just add a section for authorizing against the `fulcrologic` repository:

[source, xml]
-----
<settings>
    <servers>
        <server>
            <id>fulcrologic</id>
            <username>YOUR-EMAIL-ADDRESS</username>
            <password>YOUR-MVN-PASSWORD</password>
        </server>
    </servers>
</settings>
-----

Each project that you use with Copilot will also need to specify that it uses the `fulcrologic` repository. You can
do this in the global deps.edn file (once), or on each project individually:

[source, clojure]
-----
{:mvn/repos {"fulcrologic" {:url "https://mvn.fulcrologic.com"}}
 ...}
-----


=== Running the Copilot Daemon

You have two choices when running the Copilot Daemon: Use the `clojure` command or a runnable jar.

==== Runnable JAR

The maven dependency for the daemon *is* actually a runnable jar. If you want to run it this way, then first specify
it as a dependency of *any* project, resolve the dependencies (which will download it), and then copy the jar file
from the maven repository cache.  Usually this cache is under the path `~/.m2/repository`, where
the actual artifacts can be found under subdirectories from there. For example: `/com/fulcrologic/copilot-daemon/...`.

If you were to copy the jar to `/usr/local/jars/copilotd.jar`, then you'd run it with:

[source, bash]
-----
java -jar /usr/local/jars/copilotd.jar
-----

==== Running Via Deps

The deps approach allows you to combine the downloading, version management, and execution into one simple
setup. You just have to add this in your global deps file:


[souce]
-----
{:mvn/repos {"fulcrologic" {:url "https://mvn.fulcrologic.com"}}
 :aliases
  {:copilotd
    {:extra-deps {com.fulcrologic/copilot-daemon {:mvn/version "1.0.0-SNAPSHOT"}}
     :exec-fn com.fulcrologic.copilot.daemon.main/-main}}}
-----

and you should then be able to start it with:

[source, bash]
-----
clojure -X:copilotd
-----

Be sure to use a version of the daemon that matches your copilot checker version.


=== The Checker

A checker is a persistent process that runs the *environment* of your program. This is what enables Copilot to
understand your specs, no matter how complex they are, or what strange features they may use.
When designing Copilot we decided that it would
be best if the checker *not* run in your development REPL (even though it has everything the checker needs).
*You* still need to work at full speed, and you should not have tooling interfering with your ability to start/stop
your REPL, or otherwise block your normal development progress.

We were also careful to minimize the checker's runtime dependencies, so they do not conflict with things you use. We did not
want you to have to juggle the version of libraries you use in order to run Copilot!

The primary dependency is the most recent version of https://github.com/fulcrologic/guardrails[Guardrails]. You cannot
write Copilot-supported functions without that.

The Copilot checker for Clojure also includes the following dependencies on the classpath when you run it:

[source]
-----
 :deps    {com.fulcrologic/guardrails     {:mvn/version "1.x.x"}
           org.clojure/core.async         {:mvn/version "1.0.567"}
           org.clojure/test.check         {:mvn/version "1.1.0"}
           org.clojure/tools.namespace    {:mvn/version "1.0.0"}}
-----

Copilot requires at least Clojure 1.9.

These libraries tend to follow the "higher version means better" philosophy, so we hope they do not
conflict with your application. Please let us know if these dependencies cause problems with
starting or running the checker.

=== Clojure

The easiest way to set up a Clojure checker is to add the following to your `deps.edn`:

[source]
-----
{:aliases {:clj-checker {:extra-deps {com.fulcrologic/copilot {:mvn/version "x.x.x"}}
                         :exec-fn    com.fulcrologic.copilot.checkers.clojure/start!
                         :exec-args  {:src-dirs ["src/main" "src/test"]}}}}
-----

// TASK: Anthony, do we need src-dirs???  Seems like all the file locating could be done via io/resource, and then
// leveraging the URL it returns.
The `src-dirs` option is required, and indicates the base classpath location for any files you will
check.  Future releases will derive this information automatically.

==== Initial Namespace

The checker loads pretty much like any other Clojure program. You use deps to configure a classpath, and then
some namespace (optionally) gets loaded.

Since we want the checker to know about your specs and code it is a good idea to create a namespace that
contains requires for the main bits of your application. This will cause them to all load at checker startup and ensure
the checker has all the information it needs.

For example, you might create:

[source]
-----
(ns checker-startup
  (:require
    [com.my-company.my-extra-specs]
    [com.my-company.my-app-entry-point]))
-----

==== Starting The Checker

You must start the checker in your project root. You can add a `main-ns` key to exec-args, or include it as
a command line argument:

[source, bash]
-----
$ clj -A:aliases:for:development -X:clj-checker :main-ns checker-startup
-----

The `:main-ns` points the checker to your project's primary namespace, or the special checker startup namespace.
described in the prior section.

IMPORTANT: Your project should avoid doing things as top-level namespace side-effects, because that could interfere with
the checker's ability to reload your namespaces and might otherwise run things you do not want the checker to run.
We assume you're using something like `mount` or `component` and that
namespaces can be (re)loaded without causing harm.

Once you have a checker running, you're ready to check some files! Read more about that in the various IDE/Editor
integration chapters.

=== Clojurescript (Browser)

NOTE: The early access releases do not include Clojurescript support. Our early releases are for Clojure, but the design
is built to work with any target runtime.  If there is sufficient demand for Clojurescript support we have
a working checker that just needs more product refinement and will be prioritized if that demand materializes.

