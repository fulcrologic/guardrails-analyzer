= Copilot User Guide

== General Overview

In order to obtain the most accurate results the checkers themselves must run in the real runtime environment of your
application. This allows the tool to leverage your real code instead of it being a pure source-level analysis. These
low-level checkers connect to a central daemon. The daemon server both as a control for the system and as a gathering
place for all reports about the source of your program.

Editors also connect to the daemon and issue requests for source analysis, and receive the resulting information gathered
from the various checkers running on your source.

[ditaa]
-----
   +------------------+ +------------------+
   | Checker (CLJ)    | | Checker (CLJS)   |
   | In JVM           | | Browser/Node/??? |
   +------------------+ +------------------+
                  ^         ^
                  |         |
                  +----+----+
                       |
                       v
                   +--------+
                   | Daemon |
                   +--------+
                       ^
                       |
          +---------+--+-------+
          |         |          |
          v         v          v
   +---------+ +---------+
   | Editor  | | Editor  | ...
   +---------+ +---------+
-----

== Checker Daemon

=== Configuring the Daemon

The daemon has default settings and will attempt to bind to port 3000 on localhost. If you'd like to override this then
you can create a simple `.edn` file like so:

[source]
-----
{:org.httpkit.server/config       {:port 3050}}
-----

Place that file in a well-known (to you) path.

==== License  (TODO)

The daemon requires a valid license to run. You can place your license key in your custom config file:

[source]
-----
{:license "license text"}
-----

=== Running the Daemon

You must start the checker daemon in the root of your project. If you are using a custom config file then you
will need to know the *absolute* path to that config file.

Say you created `/Users/joe/config.edn`. You'd start the daemon with:

[source, bash]
-----
$ java -Dconfig=/Users/joe/config.edn -jar GRDaemon.jar
-----


== Editor Plugins

=== IntelliJ

=== Vim

=== Emacs

== Checkers

=== Clojure

The easiest way to set up a Clojure checker is to add the following to your `~/.clojure/deps.edn` (global clojure deps):

[source]
-----
{:aliases {:clj-checker {:extra-deps {com.fulcrologic/guardrails-pro {:mvn/version "x.x.x"}}
                         :exec-fn    com.fulcrologic.guardrails-pro.checkers.clojure/start!
                         :exec-args  {:src-dirs ["src/main" "src/test"]}}}}
-----

The `src-dirs` option should be what you most often use for the source paths in your projects. These paths will be
refreshed by the checker JVMs. You can override these options at the command line.

To start it (in your project root):

[source, bash]
-----
$ clj -A:you:aliases:for:development -X:clj-checker :main-ns your.main.ns :src-dirs '["src" "test"]'
-----

The `:main-ns` points the checker to your projects primary namespace. This is the namespace it will initially load,
and should be a namespace that requires (transitively) the code that you will be working with. Thus, it will typically
be some kind of entry point namespace.

IMPORTANT: Your project should avoid starting things as top-level namespace side-effects, because that will interfere with
the checker's ability to reload your namespaces. It assumes you're using something like `mount` or `component` and that
namespaces can be (re)loaded without causing harm.

So, a project-local configuration for the clj checker could be made much simpler to run:

[source]
-----
{:aliases {:clj-checker {:extra-deps {com.fulcrologic/guardrails-pro {:mvn/version "x.x.x"}}
                         :exec-fn    com.fulcrologic.guardrails-pro.checkers.clojure/start!
                         :exec-args  {:src-dirs ["src/main" "src/test"]
                                      :main-ns your.main.ns}}}}
-----

which could then be run with:

[source, bash]
-----
$ clj -X:clj-checker
-----

=== Clojurescript (Browser)

Running a checker for clojurescript requires you build the checker into your CLJS build. We recommend using Shadow CLJS,
but any clojurescript build pipeline should work.

You must first create a target file to compile, which is a small boilerplate file that looks like this:

[source]
-----
(ns cljs-checker
  (:require
    [your.entry-point.ns]
    [com.fulcrologic.guardrails-pro.checkers.browser :as checker]))

(defn init []
  (checker/start! {}))

(defn reload []
  (checker/reload!))
-----

And the configure that to be the target to be compiled. For shadow-cljs, you can add a build config like so:

[source]
-----
{:dev-http {9001 "resources/public"}
 :builds {:cljs-checker {:target     :browser
                         :output-dir "resources/public/js/cljs-checker"
                         :asset-path "js/cljs-checker"
                         :modules    {:main {:init-fn cljs-checker/init}}
                         :dev        {:compiler-options {:external-config {:guardrails {:throw? false :mode :pro}}}}
                         :devtools   {:after-load self-checker/reload}}}}
-----

You'll also need an HTML file that will load the resulting js file that can be served from, for example, the shadow-cljs
dev server (in `resources/public/checker.html` for the above config):

[source, html]
-----
<!DOCTYPE html>
<html>
  <head>
    <title>CLJS Checker</title>
    <meta charset="UTF-8">
    <link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.7.8/dist/semantic.min.css" rel="stylesheet">
  </head>
  <body>
    <div id="checker"></div>
    <script src="/js/cljs-checker/main.js" type="text/javascript"></script>
  </body>
</html>
-----

so that the overall checker can be run by loading `http://localhost:9001/checker.html` in a browser.

== Writing Good Function Signatures

You'll get the best results from the checker if you follow some guidelines about writing good specs and function
signatures. The following sections contain some general rules to follow that will help you get started.


=== Rule 1 â€“ Keep Specifications Constrained to Data that is Used

Be specific about exactly what the function *itself* uses. Don't overspec just because some data *might* flow in or out
of a function that the function itself doesn't care about.

For example, say you have a spec for an entity that goes in your database. This spec is used to ensure you never put
invalid data in the database:

[source]
-----
(s/def ::person (s/keys :req [:person/first-name :person/family-name :person/address :person/spouse :person/children]))
-----

When writing functions you should almost never use the `::person` spec to indicate an argument's "type". The
obvious exception is for a function that puts the thing in a database, as it obviously requires exactly
that spec. Instead, you should carefully select the data you need (if using spec 2 you would use schema/select):

[source]
-----
(>defn with-full-name [{:person/keys [first-name last-name] :as person}]
  [(s/keys :req [:person/first-name :person/last-name]) => (s/keys :req [:person/full-name])]
  (assoc person :person/full-name (str first-name " " last-name)))
-----

This practice has several benefits:

1. The checker won't try to explore generating keys for this function that are not even used by it.
2. Usages of the function won't generate checker messages about "missing" or "incorrect" values that *might* be in the
map passed as a parameter (for which the target function has no use).

=== Rule 2 - Leverage the Pure Annotation Heavily

One of the biggest helpers when writing specs is to tell the checker that it can use the function itself as a tool
to propagate samples through the code when running checks. Not only does this give you much more accurate results, but
it also fixes the "generality vs. specificity" problem for general type signatures.

Consider the function from the prior section. When used in a context like so:

[source]
-----
(>defn calculate-package-price [{:person/keys [age]}]
 [(s/keys :req [:person/age]) => number?]
 ...)

(>defn some-helper [person]
  [(s/keys :req [:person/first-name :person/last-name :person/age]) => (s/keys :req [:person/full-name :insurance/cost])]
  (let [p2 (with-full-name person)
        price (calculate-package-price p2)]
    (assoc ps :insurance/cost price)))
-----

It the checker does not know that `with-full-name` flows information through to `p2`, then it will issue an error that
required data in `calculate-package-cost` *might* not be satisfied. If the `with-full-name` is declare as a pure function
then it will understand the data flow and not issue such errors.

[source]
-----
(>defn with-full-name [{:person/keys [first-name last-name] :as person}]
  ^:pure [(s/keys :req [:person/first-name :person/last-name]) => (s/keys :req [:person/full-name])]
  (assoc person :person/full-name (str first-name " " last-name)))
-----

In cases where your function flows data *and* has side-effects you can use metadata on the
function signature to write a pure version of the function for checking purposes.

[source]
-----
(>defn launch-rocket! [target]
  ^{:pure-fn (fn [target] true)}
  [::geocoordinate => boolean?]
  ...)
-----

This allows you to help the system understand how the data flows without actually causing side effects during the checks
themselves. The checker will *never* run your code unless you declare it pure somehow.

WARNING: If you declare a function as pure then the checker will consider it safe to run. It does no recursive checking
to make sure you have not accidentally caused a nested side-effect. We hope to address this in an upcoming version.

// NOTE: We can probably have the `>defn` macro emit no body in functions that are not declared pure. This would eliminate
// the danger.
